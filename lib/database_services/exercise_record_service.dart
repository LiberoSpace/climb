import 'dart:convert';

import 'package:climb/database/database.dart';
import 'package:drift/drift.dart';
import 'package:flutter/foundation.dart';

class ExerciseRecordWithJoin {
  ExerciseRecordWithJoin(this.exerciseRecord, this.location);

  // The classes are generated by drift for each of the tables involved in the
  // join.
  final ExerciseRecord exerciseRecord;
  final Location location;
}

class ExerciseRecordModel extends ChangeNotifier {
  final AppDatabase db;

  ExerciseRecordModel({required this.db});

  Future<ExerciseRecordWithJoin?> getUnFinishedExerciseRecord() async {
    try {
      var query = db.select(db.exerciseRecords).join([
        leftOuterJoin(db.locations,
            db.locations.id.equalsExp(db.exerciseRecords.location)),
      ])
        ..where(db.exerciseRecords.isFinished.equals(false));

      var row = await query.getSingleOrNull();
      if (row != null) {
        return ExerciseRecordWithJoin(
          row.readTable(db.exerciseRecords),
          row.readTable(db.locations),
        );
      }

      return null;
    } catch (e) {
      print(e);
      rethrow;
    }
  }

  Stream<ExerciseRecordWithJoin> watchExerciseRecordWithJoin(
      int exerciseRecordId) {
    try {
      var query = db.select(db.exerciseRecords).join([
        leftOuterJoin(db.locations,
            db.locations.id.equalsExp(db.exerciseRecords.location)),
      ])
        ..where(
          db.exerciseRecords.id.equals(exerciseRecordId),
        );

      return query.watchSingle().map((row) => ExerciseRecordWithJoin(
            row.readTable(db.exerciseRecords),
            row.readTable(db.locations),
          ));
    } catch (e) {
      print(e);
      rethrow;
    }
  }

  Future<List<ExerciseRecordWithJoin>> getExerciseRecords(
      {int? limit, int? offset}) async {
    try {
      var query = db.select(db.exerciseRecords).join([
        leftOuterJoin(db.locations,
            db.locations.id.equalsExp(db.exerciseRecords.location)),
      ])
        ..orderBy(
          [
            OrderingTerm(
              expression: db.exerciseRecords.createdAt,
              mode: OrderingMode.desc,
            )
          ],
        )
        ..limit(limit ?? 8, offset: offset);

      var rows = await query.get();
      return rows.map((row) {
        return ExerciseRecordWithJoin(
          row.readTable(db.exerciseRecords),
          row.readTable(db.locations),
        );
      }).toList();
    } catch (e) {
      print(e);

      return [];
    }
  }

  Future<int> createExerciseRecord({
    required String fileName,
    required int locationId,
  }) async {
    try {
      var recordId = await db.into(db.exerciseRecords).insert(
            ExerciseRecordsCompanion.insert(
              fileName: fileName,
              location: locationId,
            ),
          );

      notifyListeners();
      return recordId;
    } catch (e) {
      print(e);

      rethrow;
    }
  }

  Future<int> updateExerciseRecord({
    required int exerciseRecordId,
    int? locationId,
    String? fileName,
    bool? isFinished,
  }) async {
    try {
      var affectedRowCnt = await (db.update(db.exerciseRecords)
            ..where(
              (tbl) => tbl.id.equals(exerciseRecordId),
            ))
          .write(
        ExerciseRecordsCompanion(
          fileName: fileName != null ? Value(fileName) : const Value.absent(),
          location:
              locationId != null ? Value(locationId) : const Value.absent(),
          isFinished:
              isFinished != null ? Value(isFinished) : const Value.absent(),
        ),
      );
      notifyListeners();
      return affectedRowCnt;
    } catch (e) {
      print(e);
      rethrow;
    }
  }

  Future<void> deleteExerciseRecord(int exerciseRecordId) async {
    try {
      var query = db.delete(db.exerciseRecords)
        ..where((t) => t.id.equals(exerciseRecordId));
      await query.go();

      notifyListeners();
    } catch (e) {
      rethrow;
    }
  }
}
